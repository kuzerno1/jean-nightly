import { useState, useCallback } from 'react'
import { invoke } from '@/lib/transport'
import { toast } from 'sonner'
import { isBaseSession, type Worktree } from '@/types/projects'
import {
  useArchiveWorktree,
  useCloseBaseSession,
  useDeleteWorktree,
  useOpenWorktreeInFinder,
  useOpenWorktreeInTerminal,
  useOpenWorktreeInEditor,
  useRunScript,
} from '@/services/projects'
import { usePreferences } from '@/services/preferences'
import { useSessions } from '@/services/chat'
import { useTerminalStore } from '@/store/terminal-store'
import { useChatStore } from '@/store/chat-store'
import type { SessionDigest } from '@/types/chat'

interface UseWorktreeMenuActionsProps {
  worktree: Worktree
  projectId: string
}

export function useWorktreeMenuActions({
  worktree,
  projectId,
}: UseWorktreeMenuActionsProps) {
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false)
  const archiveWorktree = useArchiveWorktree()
  const closeBaseSession = useCloseBaseSession()
  const deleteWorktree = useDeleteWorktree()
  const openInFinder = useOpenWorktreeInFinder()
  const openInTerminal = useOpenWorktreeInTerminal()
  const openInEditor = useOpenWorktreeInEditor()
  const { data: runScript } = useRunScript(worktree.path)
  const { data: preferences } = usePreferences()
  const { data: sessionsData } = useSessions(worktree.id, worktree.path)
  const isBase = isBaseSession(worktree)

  // Check if any session has at least one message (for recap generation)
  const hasMessages = sessionsData?.sessions?.some(
    session => session.messages.length > 0
  )

  const handleRun = useCallback(() => {
    if (runScript) {
      useTerminalStore.getState().startRun(worktree.id, runScript)
    }
  }, [runScript, worktree.id])

  const handleOpenTerminalPanel = useCallback(() => {
    useTerminalStore.getState().addTerminal(worktree.id)
  }, [worktree.id])

  const handleOpenInFinder = useCallback(() => {
    openInFinder.mutate(worktree.path)
  }, [openInFinder, worktree.path])

  const handleOpenInTerminal = useCallback(() => {
    openInTerminal.mutate({
      worktreePath: worktree.path,
      terminal: preferences?.terminal,
    })
  }, [openInTerminal, worktree.path, preferences?.terminal])

  const handleOpenInEditor = useCallback(() => {
    openInEditor.mutate({
      worktreePath: worktree.path,
      editor: preferences?.editor,
    })
  }, [openInEditor, worktree.path, preferences?.editor])

  const handleArchiveOrClose = useCallback(() => {
    if (isBase) {
      closeBaseSession.mutate({ worktreeId: worktree.id, projectId })
    } else {
      archiveWorktree.mutate({ worktreeId: worktree.id, projectId })
    }
  }, [isBase, closeBaseSession, archiveWorktree, worktree.id, projectId])

  const handleDelete = useCallback(() => {
    deleteWorktree.mutate({ worktreeId: worktree.id, projectId })
    setShowDeleteConfirm(false)
  }, [deleteWorktree, worktree.id, projectId])

  const handleOpenJeanConfig = useCallback(() => {
    openInEditor.mutate({
      worktreePath: `${worktree.path}/jean.json`,
      editor: preferences?.editor,
    })
  }, [openInEditor, worktree.path, preferences?.editor])

  const handleGenerateRecap = useCallback(async () => {
    const sessions = sessionsData?.sessions ?? []
    const sessionWithMessages = sessions.find(s => s.messages.length >= 2)

    if (!sessionWithMessages) {
      toast.error('No session with enough messages for recap')
      return
    }

    const toastId = toast.loading('Generating recap...')

    try {
      const digest = await invoke<SessionDigest>('generate_session_digest', {
        sessionId: sessionWithMessages.id,
      })

      useChatStore.getState().markSessionNeedsDigest(sessionWithMessages.id)
      useChatStore.getState().setSessionDigest(sessionWithMessages.id, digest)

      invoke('update_session_digest', {
        sessionId: sessionWithMessages.id,
        digest,
      }).catch(err => {
        console.error('[useWorktreeMenuActions] Failed to persist digest:', err)
      })

      toast.success(
        <div className="space-y-1">
          <div className="font-medium">{digest.chat_summary}</div>
          <div className="text-xs text-muted-foreground">
            {digest.last_action}
          </div>
        </div>,
        { id: toastId, duration: 8000 }
      )
    } catch (error) {
      toast.error(`Failed to generate recap: ${error}`, { id: toastId })
    }
  }, [sessionsData?.sessions])

  return {
    // State
    showDeleteConfirm,
    setShowDeleteConfirm,
    isBase,
    hasMessages,
    runScript,
    preferences,

    // Handlers
    handleRun,
    handleOpenTerminalPanel,
    handleOpenInFinder,
    handleOpenInTerminal,
    handleOpenInEditor,
    handleArchiveOrClose,
    handleDelete,
    handleOpenJeanConfig,
    handleGenerateRecap,
  }
}
